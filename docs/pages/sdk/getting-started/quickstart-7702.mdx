# Quickstart -- EIP-7702

EIP-7702 is an upcoming Ethereum upgrade that will allow for attaching a piece of EVM code to a EOA, effectively turning it into a "dual account" that can function simultaneously as a EOA and a smart account.

In practical terms, this means that existing EOA users can now enjoy most of the benefits of AA, such as gas sponsorship, transaction batching, session keys, chain abstraction, and more.  Note that since the account is both a smart account and a EOA, true "key rotation" is not possible since the EOA key will always maintain root access to the account.

In this example, we will upgrade a EOA into a ZeroDev smart account ([Kernel](https://github.com/zerodevapp/kernel)) and send a gasless batched transaction from it.

## Complete example

Here's [the complete code example](https://github.com/zerodevapp/zerodev-examples/tree/7702/7702/7702.ts) for you to reference as you follow along.

## Install packages

You will be using the following packages:

```bash
npm i @zerodev/sdk @zerodev/ecdsa-validator viem
```

## Create a project for a 7702-compatible network

In this example, we will use [the Odyssey testnet](https://hub.conduit.xyz/odyssey), but you can use any 7702-compatible network.

Go to [the ZeroDev dashboard](https://dashboard.zerodev.app) and create a project for `Odyssey Testnet`.  Create a gas policy so that we can send sponsored transactions later.  A simple "project policy" for "100 requests per minute" will do.

Create a `.env` file as follows:

```env
PRIVATE_KEY=
BUNDLER_RPC=
PAYMASTER_RPC=
```

Use the bundler/paymaster RPCs from your project home.  For the private key, use any testing EOA key.  We will be upgrading this EOA to a smart account.

## Sign a 7702 authorization

To upgrade a EOA into a smart account, the first step is to produce a "7702 authorization," which is a signed message that specifies the address of a smart contract that should be "copied" into the EOA.  In practice, to minimize the cost of copying, this smart contract will be a proxy that points to the actual smart account implementation, which in our case is Kernel.

To produce the authorization, we use [Viem](https://viem.sh/experimental/eip7702):

```ts
import { createWalletClient, Hex, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { odysseyTestnet } from 'viem/chains'
import { eip7702Actions } from 'viem/experimental'
import { KERNEL_7702_DELEGATION_ADDRESS } from '@zerodev/sdk'

const signer = privateKeyToAccount(process.env.PRIVATE_KEY as Hex)
console.log("EOA Address:", signer.address)

const walletClient = createWalletClient({
  account: signer,
  chain: odysseyTestnet,
  transport: http(),
}).extend(eip7702Actions())

const authorization = await walletClient.signAuthorization({
  contractAddress: KERNEL_7702_DELEGATION_ADDRESS,
  delegate: true,
})
```

## Set up the ZeroDev SDK

Now that you have the authorization, you can proceed to set up the ZeroDev SDK.

```ts
import { createPublicClient } from 'viem'
import { getEntryPoint, KERNEL_V3_1 } from '@zerodev/sdk/constants'
import { createKernelAccountClient } from '@zerodev/sdk'
import { getUserOperationGasPrice } from '@zerodev/sdk/actions'
import { createKernelAccount } from '@zerodev/sdk/accounts'
import { signerToEcdsaValidator } from '@zerodev/ecdsa-validator'

const entryPoint = getEntryPoint("0.7")
const kernelVersion = KERNEL_V3_1
const publicClient = createPublicClient({
  transport: http(process.env.BUNDLER_RPC),
  chain: odysseyTestnet,
})

const ecdsaValidator = await signerToEcdsaValidator(publicClient, {
  signer,
  entryPoint,
  kernelVersion,
})

const account = await createKernelAccount(publicClient, {
  plugins: {
    sudo: ecdsaValidator,
  },
  entryPoint,
  kernelVersion,
  // Set the address of the smart account to the EOA address
  address: signer.address,
})

const paymasterClient = createZeroDevPaymasterClient({
  chain: odysseyTestnet,
  transport: http(process.env.PAYMASTER_RPC),
})

const kernelClient = createKernelAccountClient({
  account,
  chain: odysseyTestnet,
  bundlerTransport: http(process.env.BUNDLER_RPC),
  paymaster: paymasterClient,
  client: publicClient,
  userOperation: {
    estimateFeesPerGas: async ({ bundlerClient }) => {
      return getUserOperationGasPrice(bundlerClient);
    },
  },
  // Set the 7702 authorization
  eip7702auth: authorization,
})
```

Don't worry if the code doesn't make too much sense -- you can read more about the setup process [here](/sdk/core-api/create-account).

Comparing to the normal setup process, there are two main differences:

- When you set up the `account`, you specify `address: signer.address` to explicitly set the address of the smart account to the EOA address.  Otherwise, the SDK would compute the smart account address from its init data, which is how smart accounts normally work.  With 7702 however, the account address is the EOA address.

- When you set up the account client, specify `eip7702auth: authorization` so that the SDK can handle the upgrade using the authorization.

## Using the ZeroDev SDK

Now you can use the ZeroDev SDK as usual.  For example, to send a gasless batched UserOp:

```ts
const userOpHash = await kernelClient.sendUserOperation({
  callData: await kernelClient.account.encodeCalls([
    {
      to: zeroAddress,
      value: BigInt(0),
      data: "0x",
    },
    {
      to: zeroAddress,
      value: BigInt(0),
      data: "0x",
    },
  ]),
})

await kernelClient.waitForUserOperationReceipt({
  hash: userOpHash,
})

console.log("UserOp completed")
```

Congratulations!  You just sent your first gasless, batched transaction using a EOA.  You can see it by looking up your EOA account with [the Odyssey block explorer](https://odyssey-explorer.ithaca.xyz/).  Note that you have to look under "Internal Transactions" because UserOps do not appear as regular transactions.

Easy, right?  Now explore the rest of the ZeroDev docs and see what you can do with your "smart EOA."
